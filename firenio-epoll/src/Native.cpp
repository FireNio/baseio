/* DO NOT EDIT THIS FILE - it is machine generated */

#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <sys/epoll.h>
#include <sys/eventfd.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>


#include "jni.h"

#ifndef _Included_com_firenio_component_Native
#define _Included_com_firenio_component_Native
#ifdef __cplusplus
extern "C" {
#endif

static int make_socket_non_blocking(int fd);
static int touch_event(int epfd,int fd,int op, int state);


JNIEXPORT jint JNICALL Java_com_firenio_component_Native_set_1socket_1opt0
  (JNIEnv * e, jclass c,jint fd,jint type, jint name,jint value){
    socklen_t len = sizeof(value);
    return setsockopt(fd, type, name, &value, len);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_get_1socket_1opt0
  (JNIEnv * e, jclass c,jint fd,jint type, jint name){
    int optval = 0;
    socklen_t len = sizeof(optval);
    int res = getsockopt(fd, type, name, &optval, &len);
    if (res == -1) {
        return -1;
    }
    return optval;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_get_1port0
  (JNIEnv * e, jclass c,int fd){
    struct sockaddr_in local_address;
    socklen_t addr_size = sizeof(local_address);
    if(getsockname(fd, (struct sockaddr *)&local_address, &addr_size) == -1){
      return 0;
    }
	  return local_address.sin_port;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_new_1event_1fd0
  (JNIEnv * e, jclass c){
    return eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_event_1fd_1write0
  (JNIEnv * e, jclass c, jint fd, jlong v){
    return eventfd_write(fd, (eventfd_t) v);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_event_1fd_1read0
  (JNIEnv * e, jclass c, jint fd){
    uint64_t eventfd_t;
    return eventfd_read(fd, &eventfd_t);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_size_1of_1epoll_1event
  (JNIEnv * e, jclass c){
    return sizeof(epoll_event);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_size_1of_1sockaddr_1in
  (JNIEnv * e, jclass c){
    return sizeof(sockaddr_in);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_connect0
  (JNIEnv * e, jclass c, jstring host, jint port){
    const char *hhost = e->GetStringUTFChars(host, NULL);
    struct sockaddr_in servaddr;
    int fd = socket (AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);
    if(fd == -1){
      return -1;
    }
    memset(&servaddr,0,sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(port);
    hostent* host1 = gethostbyname(hhost);
    inet_pton(AF_INET,hhost,&servaddr.sin_addr);
    if(connect(fd,(struct sockaddr*)&servaddr,sizeof(servaddr)) == -1){
      if(errno == EINPROGRESS){
        return fd;
      }else{
        close(fd);
        return -1;
      }
    }
    return fd;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_accept0
  (JNIEnv * e, jclass c, jint epfd, jint listenfd, jlong address){
    struct sockaddr_in6 *addr = (struct sockaddr_in6 *)(address);
    socklen_t addrlen = 32;
    memset(addr,0,32);
    int fd = accept(listenfd,(struct sockaddr *)addr,&addrlen);
    if (fd == -1){
      return -1;
    }
    int on = 1;
    if(setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0){
      close(fd);
      return -1;
    }
    return fd;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_bind0
  (JNIEnv * e, jclass c, jstring host, jint port, jint backlog){
    int listenfd = socket(AF_INET6,SOCK_STREAM,0);
    if (listenfd == -1){
      return -1;
    }
    int on = 1;
    if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1){
      close(listenfd);
      return -1;
    }
    if(make_socket_non_blocking(listenfd) == -1){
      close(listenfd);
      return -1;
    }
    const char *hhost = e->GetStringUTFChars(host, NULL);
    struct sockaddr_in6 servaddr;
    memset(&servaddr,0,sizeof(servaddr));
    servaddr.sin6_family = AF_INET6;
    servaddr.sin6_port = htons(port);
    inet_pton(AF_INET,hhost,&servaddr.sin6_addr);
    if (bind(listenfd,(struct sockaddr*)&servaddr,sizeof(servaddr)) == -1){
      close(listenfd);
      return -1;
    }
    if(listen(listenfd,backlog) == -1){
      close(listenfd);
      return -1;
    }
    return listenfd;
    // struct addrinfo hints;
    // struct addrinfo *result, *rp;
    // int s, sfd, on;
    // const char *hhost = e->GetStringUTFChars(host, NULL);
    // const char *pport = e->GetStringUTFChars(port, NULL);
    // memset(&hints, 0, sizeof(struct addrinfo));
    // hints.ai_family = AF_UNSPEC;    /* Return IPv4 and IPv6 choices */
    // hints.ai_socktype = SOCK_STREAM;    /* We want a TCP socket */
    // hints.ai_flags = AI_PASSIVE;    /* All interfaces, will be ignored if host is not null */

    // s = getaddrinfo(hhost, pport, &hints, &result);
    // if (s != 0){
    //     return -1;
    // }
    // for (rp = result; rp != NULL; rp = rp->ai_next){
    //     sfd = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    //     if (sfd == -1)
    //         continue;
    //     on = 1;
    //     s =  setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
    //     if (s != 0) {
    //         return -1;
    //     }
    //     s = bind(sfd, rp->ai_addr, rp->ai_addrlen);
    //     if (s == 0){
    //         /* We managed to bind successfully! */
    //         break;
    //     }
    //     close(sfd);
    // }
    // if (rp == NULL){
    //     return -1;
    // }
    // freeaddrinfo(result);
    // return sfd;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_close0
  (JNIEnv * e, jclass c, jint fd){
    return close(fd);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_epoll_1add0
  (JNIEnv * e, jclass c, jint epfd, jint fd, jint state){
    make_socket_non_blocking(fd);
    return touch_event(epfd,fd,EPOLL_CTL_ADD,state);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_epoll_1create0
  (JNIEnv * e, jclass c, jint size){
    return epoll_create(size);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_epoll_1del0
  (JNIEnv * e, jclass c, jint epfd, jint fd){
    return touch_event(epfd,fd,EPOLL_CTL_DEL,EPOLLIN);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_epoll_1mod0
  (JNIEnv * e, jclass c, jint epfd, jint fd, jint state){
    return touch_event(epfd,fd,EPOLL_CTL_MOD,state);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_epoll_1wait0
  (JNIEnv * e, jclass c, jint epfd, jlong address, jint max_events, jlong timeout){
    int res = epoll_wait(epfd,(struct epoll_event *) address,max_events,timeout);
    if(res == -1 && errno == EINTR){
      return 0;
    }
    return res;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_read0
  (JNIEnv * e, jclass c, jint fd, jlong address, jint len){
    errno = 0;
    ssize_t res = read(fd, (void *)address, (size_t) (len));
    if (res < 1) {
      if(errno == EAGAIN){
        return 0;
      }
      return -1;
    }
    return (jint) res;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_write0
  (JNIEnv * e, jclass c, jint fd, jlong address, jint len){
    errno = 0;
    ssize_t res = write(fd, (void *)address, (size_t) (len));
    if (res < 1) {
      if(errno == EAGAIN){
        return 0;
      }
      return -1;
    }
    return (jint) res;
  }

JNIEXPORT jlong JNICALL Java_com_firenio_component_Native_writev0
  (JNIEnv * e, jclass c, jint fd, jlong iovec,jint count){
    errno = 0;
    ssize_t res = writev(fd, (struct iovec*)iovec, count);
    if (res < 1) {
      if(errno == EAGAIN){
        return 0;
      }
      return -1;
    }
    return (jlong) res;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_strerrno
  (JNIEnv * e, jclass c, jint no, jbyteArray array){
    char * cs = strerror(no);
    int len = strlen(cs);
    jboolean coff = JNI_FALSE;
    jbyte *p = e->GetByteArrayElements(array,&coff);
    memcpy(p,cs,len);
    e->ReleaseByteArrayElements(array,p,0);
    return len;
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_errno
  (JNIEnv * e, jclass c){
    return errno;
  }

static inline int touch_event(int epfd,int fd,int op, int state){
    struct epoll_event ev;
    ev.events = state;
    ev.data.fd = fd;
    return epoll_ctl(epfd,op,fd,&ev);
}

static inline int make_socket_non_blocking(int fd){
    int flags;
    if ((flags = fcntl(fd, F_GETFL, 0)) < 0 ||
         fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0) {
      return -1;
    }
    return 0;
}

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_open0
  (JNIEnv * e, jclass c,jstring path,jint op, jint pem){
    const char *file_path = e->GetStringUTFChars(path, NULL);
    return open(file_path, op, pem);
  }

JNIEXPORT jlong JNICALL Java_com_firenio_component_Native_posix_1memalign_1allocate0
  (JNIEnv * e, jclass c, jint len, jint align){
    unsigned char *buf;
    int ret = posix_memalign((void **) &buf, align, len);
    if (ret < 0) {
        return ret;
    }
    return (jlong) buf;
  }

JNIEXPORT jlong JNICALL Java_com_firenio_component_Native_file_1length0
  (JNIEnv * e, jclass c, jint fd){
    struct stat stbuf;  
    int ret = fstat(fd, &stbuf);
    if (( ret < 0) ) {
      return ret;
    }
    if((!S_ISREG(stbuf.st_mode))){
      return 0;
    }
    return (jlong)(stbuf.st_size);
  }

JNIEXPORT jlong JNICALL Java_com_firenio_component_Native_lseek0
  (JNIEnv * e, jclass c, jint fd, jlong off, jint seek_mode){
    return (jlong)(lseek(fd, off, seek_mode));
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_pread0
  (JNIEnv * e, jclass c, jint fd, jlong address, jint len, jlong off){
    return pread(fd, (void *)address, len, off);
  }

JNIEXPORT jint JNICALL Java_com_firenio_component_Native_pwrite0
  (JNIEnv * e, jclass c, jint fd, jlong address, jint len, jlong off){
    return pwrite(fd, (void *)address, len, off);
  }


int main(){ return 0;}

#ifdef __cplusplus
}
#endif
#endif